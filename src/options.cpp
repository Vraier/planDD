#include "options.h"

namespace po = boost::program_options;

void option_parser::parse_command_line(int argc, char *argv[]) {
    m_option_desc.add_options()("help", "produce help message")
        // Filepaths
        ("sas_file", po::value<std::string>(&m_values.sas_file)->default_value("output.sas"),
         "Input sas file, describing the planning problem")  //
        ("ass_file", po::value<std::string>(&m_values.ass_file)->default_value("minisat.ass"),
         "Input cnf file, containing a solution to a cnf problem")  //
        ("cnf_file", po::value<std::string>(&m_values.cnf_file)->default_value("problem.cnf"),
         "A cnf file describing the planning problem")  //
        // Program modes
        ("encode_cnf", po::bool_switch(&m_values.encode_cnf)->default_value(false),
         "encodes the planning problem into a cnf writes it to a file")  //
        ("build_bdd", po::bool_switch(&m_values.build_bdd)->default_value(false),
         "tries to build the bdd for the given planning problem")  //
        ("build_sdd", po::bool_switch(&m_values.build_sdd)->default_value(false),
         "tries to build the sdd for the given planning problem")  //
        ("single_minisat", po::bool_switch(&m_values.single_minisat)->default_value(false),
         "converts the given cnf to a solution for the planning problem")  //
        ("count_minisat", po::bool_switch(&m_values.count_minisat)->default_value(false),
         "Runs minisat to solve a cnf problem generated by this program")  //
        // DD building parameters
        ("timesteps", po::value<int>(&m_values.timesteps)->default_value(11),
         "The amount of timsteps represented by the cnf formula")  //
        ("include_mutex", po::bool_switch(&m_values.include_mutex)->default_value(false),
         "If this flag is set, the cnf encoder will include the mutexes from the sas problem in its formula")  //
        ("build_order", po::value<std::string>(&m_values.build_order)->default_value("irtyumpegc"),
         "Determins the order of conjoins when building a dd linearily and not interleaved. Must be a permutation of "
         "the string impgc; i: initial_state, rtyum: mutex, pe: precondition/effect, g: goal, c: changing atoms "
         "implication.")  //
        ("reverse_order", po::bool_switch(&m_values.reverse_order)->default_value(false),
         "Reverses the order of the conjoin operations. This has the effect that the conjoin order gets reversed but "
         "also clauses with higher timesteps get conjoined first.");  //

    po::store(po::parse_command_line(argc, argv, m_option_desc), m_argument_map);
    po::notify(m_argument_map);
}

bool option_parser::check_validity() {
    if ((m_values.encode_cnf + m_values.build_bdd + m_values.build_sdd + m_values.single_minisat +
         m_values.count_minisat) != 1) {
        std::cout << "You have to choose exactly one mode." << std::endl;
        return false;
    }
    return true;
}

void option_parser::print_help() {
    std::cout << "Currently the program can encode a planning problem into a cnf, build a bdd from it or decode a "
                 "cnf solution to a plan. You should only choose one of the options at a time."
              << std::endl;
    std::cout << m_option_desc << std::endl;
}

void option_parser::print_config() {
    std::cout << "Using the following config: " << std::endl;

    std::cout << "sas_file: " << m_values.sas_file << std::endl;
    std::cout << "ass_file: " << m_values.ass_file << std::endl;
    std::cout << "cnf_file: " << m_values.cnf_file << std::endl;

    std::cout << "encode_cnf: " << (m_values.encode_cnf ? "true" : "false") << std::endl;
    std::cout << "build_bdd: " << (m_values.build_bdd ? "true" : "false") << std::endl;
    std::cout << "build_sdd: " << (m_values.build_sdd ? "true" : "false") << std::endl;
    std::cout << "single_minisat: " << (m_values.single_minisat ? "true" : "false") << std::endl;
    std::cout << "count_minisat: " << (m_values.count_minisat ? "true" : "false") << std::endl;

    std::cout << "build_order: " << m_values.build_order << std::endl;
    std::cout << "reverse_order: " << (m_values.reverse_order ? "true" : "false") << std::endl;
    std::cout << "include_mutex: " << (m_values.include_mutex ? "true" : "false") << std::endl;
    std::cout << "timesteps: " << m_values.timesteps << std::endl;
}